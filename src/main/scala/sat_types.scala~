package my.sat

/** Essential solver types */

object Var {
  type t = Int
  def toInt(v:t) = v
  def apply(v:t) = v
}
/** Literal
 * A literal is either a positive or negavie apparence of a variable.
 */
class Lit(v:Var.t, sgn:Boolean) {
  val x = if (sgn) v + v + 1 else v + v 
  
  def sign = (x & 1) == 1
  def variable = x >> 1 
  def toInt = x
}

object Lit {
  def apply(v:Var.t, sign:Boolean) = new Lit(v,sign)
  def not(l:Lit) = new Lit(l.variable, !l.sign)
}

/** Clause
 * A clause contains a vector of literals
 * 
 */
class Clause(lits: Array[Lit], 
	     val learnt:Boolean) {
  // Header info

  val lit = lits.clone // Local copy 

  // The following was implemented as union in MiniSAT.
  val activity = if (learnt) 0.0 else -1.0 // Only useful for learnt
  val abst = calcAbstraction

  def calcAbstraction = {
    // Abstraction computes a uint32 representation of 
    // the bit vector corresponding to the variables in
    // the clause. 
    var abstraction = 0
    for (i <- 0 until lit.length ) {
      abstraction |= 1 << (lit(i).variable & 31)
    }
    abstraction
  }
  
  
}
